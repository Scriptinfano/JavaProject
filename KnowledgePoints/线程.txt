
 对线程的理解
   * 1、每个线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器
   * 2、一个进程中的多个线程共享相同的内存单元和内存地址空间，从同一堆中分配对象，可以访问相同的变量和对象，使得线程之间的通信更简便高效
   * 3、多个线程操作共享的系统资源可能会带来安全隐患
   * 单核与多核CPU的理解
   * 1、单核CPU是一种假线程，因为在同一个时间单元内，只能执行一个线程的任务
   * 2、一个java进程至少有三个线程，main()主线程、gc()垃圾回收线程、异常处理线程
   * 并行与并发的概念
   * 并行：多个CPU同时执行多个任务
   * 并发：一个CPU采用时间片同时执行多个任务，多个人做一件事

 创建线程
   * 有两种方法创建线程：1、扩展Thread类 2、创建一个实现Runnable接口的类，并将其实例传递给Thread对象
   * 两种方法都需要覆写run方法，run方法中是希望线程执行的代码
   * 启动线程：调用Thread对象的start()方法
   * 结束线程：在run方法中返回或抛出异常

 线程的六种状态：
   * 1、NEW 线程对象未调用start()方法，处于未启动状态
   * 2、RUNNABLE 线程正在执行的状态
   * 3、BLOCKED 线程正在等待另一个锁，以便访问某个对象的状态
   * 4、WAITING 线程无限期等待另一个线程执行某个动作的状态
   * 5、TIMED_WAITING 线程在指定时间内等待另一个线程执行某个动作的状态
   * 6、TERMINATED 线程退出的状态
   * 表示以上六种状态的枚举常量封装在java.lang.Thread.State枚举类中。

 线程类Thread的常用方法：
   * public String getName() 返回线程名称
   * public Thread.State getState() 返回线程状态
   * public void interrupt() 中断线程
   * public void start() 启动线程
   * public static void sleep(long millis) 让线程睡眠指定的时间，在这段时间中线程处于阻塞状态
   * public static Thread currentThread() 返回当前工作线程
   * public static void yield() 调用此方法的线程释放当前CPU的执行权
   * public final void join() 若在A线程调用B线程的join方法，表示：当执行到此方法，A线程停止执行直到B线程执行完毕，A线程才执行之后的代码
   * public final boolean isAlive() 判断当前线程是否还存活

 线程优先级
   * 通过调用sleep方法让线程处于等待状态，当运行当中的线程处于等待时，优先级最高的线程将获得运行权
   * 如何设置优先级：调用线程对象调用setPriority()方法，并传递一个介于1到10之间的值
   * 得到线程的优先级： getPriority()

 注意：
   * 1、start()方法调用后线程不会立即执行而是进入就绪状态等待CPU的调度
   * 2、start()方法的调用顺序不会决定线程的执行顺序，CPU有自己的调度算法，进程的调度顺序是不确定的
   * 3、一个线程只能被start()一次，如果一个线程在启动之后再次调用start()方法则会抛出非法线程状态（IllegalThreadStateException）异常

 比较创建多线程的两种方式
   * 1、建议使用实现Runnable接口的方式实现线程的创建，因为继承Thread类会剥夺此类继承其他类的权利，因为java中只有单继承
   * 2、如果多线程共享某数据，应该使用实现接口的方式创建线程

 导致线程阻塞的原因：
   * 1、等待同步锁：只让一个线程处理共享数据，其他进程因等待同步锁而处于阻塞状态
   * 2、调用sleep()函数
   * 3、在a线程中让线程b调用join方法，a线程进入阻塞状态
   * 4、调用wait()

 导致线程从阻塞状态回到就绪状态的原因：
   * 1、sleep()时间到
   * 2、join()结束
   * 3、获取同步锁
   * 4、调用notify()或notifyAll()

 线程安全问题的解决
   * 原因：线程执行run方法不是执行完之后其他线程才进来，有可能是一个线程刚输出完数据但是还没有更新数据，另一个线程就进来读取了没有更新的数据
   * 解决方法：
     * 线程在执行run方法时，给方法加锁，其他任何线程都无法执行该方法，只有当线程执行完之后开锁，其它线程才能进来
     * 在java中通过同步机制来解决线程的安全问题
       * 方式一：同步代码块
       * 语法：synchronized(同步监视器){//需要被同步的代码}
       * 什么是需要被同步的代码：操作共享数据（多个线程共同操作的变量）的代码即为需要被同步的代码
       * 什么是同步监视器：俗称叫锁，任何一个类的对象可以充当锁，但是要求多个线程要用同一把锁，为了方便一般就使用静态的全局Object类对象来充当锁
       * 如果进程通过继承Thread方法实现，慎用this充当同步监视器，建议使用类名.class的方法充当监视器
     * 方式二：同步方法
       * 如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明为同步的
       * 同步方法仍然有同步监视器，不需要显式声明
         * 非静态的同步方法的同步监视器是this
         * 静态同步方法的同步监视器是类名.class
