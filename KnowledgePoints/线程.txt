        创建线程
         * 有两种方法创建线程：1、扩展Thread类 2、创建一个实现Runnable接口的类，并将其实例传递给Thread对象
         * 两种方法都需要覆写run方法，run方法中是希望线程执行的代码
         * 启动线程：调用Thread对象的start()方法
         * 结束线程：在run方法中返回或抛出异常

        线程的六种状态：
         * 1、new 线程对象未调用start()方法，处于未启动状态
         * 2、runnable 线程正在执行的状态
         * 3、blocked 线程正在等待另一个锁，以便访问某个对象的状态
         * 4、waiting 线程无限期等待另一个线程执行某个动作的状态
         * 5、timed_waiting 线程在指定时间内等待另一个线程执行某个动作的状态
         * 6、terminated 线程退出的状态
         * 表示以上六种状态的值封装在java.lang.Thread.State枚举中。分别是：
         * NEW RUNNABLE BLOCKED WAITING TIMED_WAITING TERMINATED

        线程类Thread的常用方法：
         * public String getName() 返回线程名称
         * public Thread.State getState() 返回线程状态
         * public void interrupt() 中断线程
         * public void start() 启动线程
         * public static void sleep(long millis) 在指定的毫秒时间内停止当前线程
         * public static Thread currentThread() 返回当前工作线程
         * public static void yield() 调用此方法的线程释放当前CPU的执行权
         * public final void join() 若在A线程调用B线程的join方法，表示：当执行到此方法，A线程停止执行直到B线程执行完毕，A线程才执行之后的代码
         * public final boolean isAlive() 判断当前线程是否还存活

        线程优先级
         * 通过调用sleep方法让线程处于等待状态，当运行当中的线程处于等待时，优先级最高的线程将获得运行权
         * 如何设置优先级：调用线程对象调用setPriority()方法，并传递一个介于1到10之间的值
         * 得到线程的优先级： getPriority()

        注意：
         * 1、start()方法调用后线程不会立即执行而是进入就绪状态等待CPU的调度
         * 2、start()方法的调用顺序不会决定线程的执行顺序，CPU有自己的调度算法，进程的调度顺序是不确定的
         * 3、一个线程只能被start()一次，如果一个线程在启动之后再次调用start()方法则会抛出异常
